@page "/"

@inject IUserAccessor UserAccessor
@inject IEnumerable<PermissionDescription> Permissions

<PageTitle>Home</PageTitle>

<h1>Welcome to the Permissions Package.</h1>
<div class="row">
    <div class="col-6">
        The Permissions Package extends upon the IUserAccount in the <a href="https://github.com/CleveZonen/CleveCoding.Kernel" target="_blank">CleveCoding.Kernel</a> foundational package.
        The <strong>UserAccount</strong> and <strong>UserAccessor</strong> are now found in the Permissions Package.
    </div>
    <div class="col">
        <strong>Discovered Permissions:</strong>
        <ul>
            @foreach (var permDesc in Permissions)
            {
                <ProtectedArea Resource="@permDesc.Resource" Action="permDesc.Action">
                    <li>@($"{permDesc.Resource}.{permDesc.Action} - {permDesc.Description}")</li>
                </ProtectedArea>
            }
        </ul>
    </div>
    <div class="col">
        <strong>Current User:</strong>
        <p>
            User: @UserAccessor.CurrentUser?.AccountName<br />
            IsAdmin: @UserAccessor.IsAdmin(UserAccessor.CurrentUser!)
        </p>
    </div>
</div>

<h3>Implementation</h3>
<p>Implementation is relatively straight forward.</p>
<ol>
    <li>Install the CleveCoding.Permissions package with NuGet from the Cleve Github Packages.</li>
    <li>
        <p>In Program.cs add in the ServiceCollection section, after the Authentications calls:</p>
        <code>
            <pre>
    // Add the Permissions. Ensure the call is after AddAuthentication!
    builder.Services.AddCascadingAuthenticationState();
    builder.Services.AddAuthentication(NegotiateDefaults.AuthenticationScheme)
        .AddNegotiate();
    builder.Services.AddAuthorization(options =>
    {
         // By default, all incoming requests will be authorized according to the default policy.
         options.FallbackPolicy = options.DefaultPolicy;
    });
    builder.Services.AddPermissions&lt;GetItemsForIndexRequest&gt;(config =>
    {
        config.ConnectionString = builder.Configuration.GetConnectionString("DefaultConnection")!;
        config.AdminRoles = RoleNames.Administrator;
    });
            </pre>
        </code>
    </li>
    <li>
        <p>
            In Program.cs add <strong>after</strong> "<span style="font-style:italic">var app = builder.Build()</span>" is called,
            but <strong>before</strong> "<span style="font-style:italic">app.MapRazorComponents&lt;App&gt;()</span>"
        </p>
        <code>
            <pre>
    // Use the Permissions. Ensure the call is after UseAuthentication!
    app.UseAuthentication();
    app.UseAuthorization();
    await app.UsePermissions();
            </pre>
        </code>
    </li>
    <li>
        <p>In MainLayout.razor wrap the @@Body with PermissionErrorBoundary.</p>
        <code>
            <pre>
    &lt;PermissionErrorBoundary&gt;
    @@Body            
    &lt;PermissionErrorBoundary&gt;
            </pre>
        </code>
    </li>
</ol>

<p>Alternatively you can inspect the source-code of this project for implementation on <a href="https://github.com/CleveZonen/CleveCoding.Permissions" target="_blank">Github</a>.</p>

<h3>Usage</h3>
<p>Using the permissions package is even simpler than implementing it. Make sure to implement the IRequirePermission-interface on the Requests and Commands used by MediatR.</p>
<p>
    <strong>Resource:</strong> Logical name for resources/modules.<br />
    <strong>Action:</strong> User action are defined in the UserActionType enumeration.<br />
    <strong>Description:</strong> User friendly description for the permissions control panel (page for granting and revoking permissions).
</p>
<code>
    <pre>
    public record GetItemsForIndexRequest : ICommand&lt;Response&gt;, IRequirePermission
    {
        public PermissionDescription RequiredPermission => new(nameof(Item), UserActionType.ViewIndex, "Access to items index.");
    }
    </pre>
</code>

<h4>Partial Protection</h4>
<p>In <span style="font-style:italic">CleveCoding.Permissions.Web.Components</span> you can find the ProtectedArea-component, usage is very simple and is for partial protection:</p>
<code>
    <pre>
    &lt;ProtectedArea Resource="Item" Action="UserActionType.ViewDetails"&gt;
        This content is only visible to users with permission.
    &lt;ProtectedArea"&gt;
    </pre>
</code>
<p>If Access is Denied, the content is not rendered.</p>

<h4>Components Protection</h4>
<p>
    Components can be protected by inheriting from ProtectedComponent and using the RequirePermission-attribute.
    Multiple attributes can be used - if the user has permission for atleast one of them, access is granted.
</p>
<code>
    <pre>
    [RequirePermission("Item", UserActionType.ViewDetails)]
        OR
    @@attribute RequirePermission("Item", UserActionType.ViewDetails)
    </pre>
</code>
<p>If Access is Denied, the content is not rendered and PermissionErrorBoundary is used to give an custom Blazor error message.</p>

<h4>Notes</h4>
<ul>
    <li>UserAccount and UserAccessor are managed in this package.</li>
    <li>There is no registry of permissions, they are discovered by scanning for IRequirePermission in the assembly. When calling AddPermissions&lt;T&gt;() the T-type will be used to scan the containing assembly on IRequirePermission.</li>
    <li>The user- and role permissions are managed by EntityFramework Core. The ConnectionString given into AddPermissions() with PermissionConfigurations is passed to EF Core.</li>
    <li>Database migrations are checked and executed on application startup.</li>
    <li>Changes in user- and role permissions are automatically audited. The Audits can be requested with IPermissionService.</li>
    <li>All user- and role permissions are cached using IMemoryCache.</li>
    <li>The verification if an user has the permission to access an resource is automatically checked in MediatR's (behavior) pipeline based on IRequirePermission.</li>
    <li>Users with Administrator-roles are excluded on the permission verification.</li>
    <li>The CurrentUser in UserAccessor is automatically populated in the Middleware by using UserContextInitializer - no need to explicitly call TryLoadUserAsync() on every component/page.</li>
    <li>User- and role permissions are merged when populating the CurrentUser, with the user permission taking priority.</li>
    <li>The user-, role permissions and audits are encrypted before saving. So if your application doesnt already use Encryption, add an call to Encryption.SetKey(uniqueId) in Program.cs</li>
</ul>
<h5>Access with DI</h5>
<dl>
    <dt>IEnumerable&lt;PermissionDescription&gt;</dt>
    <dd>All the PermissionDescription of discovered IRequiredPermissions.</dd>
    <dt>IPermissionService</dt>
    <dd>Used to manage the user- and role permissions incl access to the audits.</dd>
    <dt>IUserAccessor</dt>
    <dd>Get the current user and methods to check if an user has the admin role.</dd>
    <dt>PermissionConfigurations</dt>
    <dd>The configurations for the Permissions Package. Contains the ConnectionString and AdminRoles.</dd>
    <dt>IUserContextInitializer</dt>
    <dd>The UserContextInitializer is used as Middleware to populate the UserAccessor (InvokeAsync), but can be manually retrieved to populate the UserAccessor.CurrentUser (InitializeAsync).</dd>
</dl>
